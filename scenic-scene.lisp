
(in-package :scenic)

;;; SCENE class.

(defclass scene ()
  ((widget :accessor widget :initarg :widget :initform nil)
   (width :accessor width :initarg :width :initform 1024)
   (height :accessor height :initarg :height :initform 768)
   (last-widget-chain :accessor last-widget-chain :initarg :last-widget-chain :initform nil)
   (mouse-captors :accessor mouse-captors :initarg :mouse-captors :initform nil)
   (dirty :accessor dirty :initarg :dirty :initform t)
   (dirty-list :accessor dirty-list :initarg :dirty-list :initform nil)
   (layedout :accessor layedout :initarg :layedout :initform nil)
   (rectangle-to-redraw :accessor rectangle-to-redraw :initarg :rectangle-to-redraw :initform nil)
   (sdl-surface :accessor sdl-surface :initarg :sdl-surface :initform nil)
   (focusables :accessor focusables :initarg :focusables :initform nil)
   (focused-index :accessor focused-index :initarg :focused-index :initform nil)))

(defun get-scene (widget)
  (if (eql (type-of widget) 'scene)
      widget
      (get-scene (parent widget))))

(defun capture-mouse (widget)
  (let ((scene (get-scene widget)))
    (if (not (member widget (mouse-captors scene)))
        (push widget (mouse-captors scene)))))

(defun release-mouse (widget)
  (let ((scene (get-scene widget)))
    (setf (mouse-captors scene)
          (remove widget (mouse-captors scene)))))

(defun invalidate (widget)
  (let ((scene (get-scene widget)))
    (setf (dirty scene) t)
    (push widget (dirty-list scene))))

(defun corners-of-widget (widget)
  (list (list (layout-left widget)
              (layout-top widget))
        (list (1- (+ (layout-left widget) (layout-width widget)))
              (layout-top widget))
        (list (layout-left widget)
              (1- (+ (layout-top widget) (layout-height widget))))
        (list (1- (+ (layout-left widget) (layout-width widget)))
              (1- (+ (layout-top widget) (layout-height widget))))))

(defmethod intersect ((object1 widget) (object2 widget))
  (dolist (corner (corners-of-widget object1))
    (if (in-widget (first corner) (second corner) object2)
        (return-from intersect t))))

(defun widget-paint-member (object list)
  (cond ((null list)
         nil)
        ((or (eq object (first list))
             (and (intersect object (first list))
                  (> (paint-order-number object)
                     (paint-order-number (first list)))))
         t)
        (t (widget-paint-member object (rest list)))))

(defun bounding-box (widget)
  (list (layout-left widget)
        (layout-top widget)
        (1- (+ (layout-left widget) (layout-width widget)))
        (1- (+ (layout-top widget) (layout-height widget)))))

(defun common-bounding-box (bbox1 bbox2)
  (list (min (first bbox1) (first bbox2))
        (min (second bbox1) (second bbox2))
        (max (third bbox1) (third bbox2))
        (max (fourth bbox1) (fourth bbox2))))

(defun paint-scene (scene)
  (if (null (dirty-list scene))
      (paint-order-walk (widget scene)
                        (lambda (object)
                          (paint object)
                          t)
                        :after-callback (lambda (object)
                                          (after-paint object)))
      (progn
        (let ((number 0))
          (paint-order-walk (widget scene)
                            (lambda (object)
                              (setf (paint-order-number object) number)
                              (incf number)
                              t)))
        (paint-order-walk (widget scene)
                          (lambda (object)
                            (when (widget-paint-member object (dirty-list scene))
                              (paint object)
                              (push object (dirty-list scene)))
                            t)
                          :after-callback (lambda (object)
                                            (when (widget-paint-member object
                                                                       (dirty-list scene))
                                              (after-paint object))))
        (setf (rectangle-to-redraw scene)
              (reduce #'common-bounding-box
                      (mapcar #'bounding-box (dirty-list scene))))))
  (setf (dirty-list scene) nil))

(defmethod measure ((object scene) available-width available-height)
  (measure (widget object) available-width available-height))

(defmethod layout ((object scene) left top width height)
  (layout (widget object) left top width height))

(defun get-widget-chain (widget-chain)
  (if (null widget-chain)
      nil
      (let ((parent-of-first (parent (first widget-chain))))
        (if (and parent-of-first (not (eql (type-of parent-of-first) 'scene)))
            (get-widget-chain (cons parent-of-first
                                    widget-chain))
            widget-chain))))

(defun hit-test (widget x y)
  (let (result)
    (paint-order-walk widget
                      (lambda (object)
                        (if (in-widget x y object)
                            (setf result object))))
    result))

(defun cascade-then-bubble (widget-chain event event-arg)
  (dolist (widget widget-chain)
    (on-event widget event event-arg :cascade)
    (when (handled event-arg)
      (return)))
  ;; then mouse-move bubble;
  (unless (handled event-arg)
    (dolist (widget (reverse widget-chain))
      (on-event widget event event-arg :bubble)
      (when (handled event-arg)
        (return)))))

(defun branch-diff (branch1 branch2)
  (cond ((null branch1) nil)
        ((null branch2) branch1)
        ((eq (first branch1) (first branch2)) (branch-diff (rest branch1)
                                                           (rest branch2)))
        (t branch1)))

(defun calculate-mouse-leave (old-chain new-chain)
  (branch-diff old-chain new-chain))

(defun calculate-mouse-enter (old-chain new-chain)
  (branch-diff new-chain old-chain))

(defun scene-handle-mouse-captors (scene event mouse-event)
  (dolist (captor (mouse-captors scene))
    (setf (handled mouse-event) nil)
    (on-event captor event mouse-event nil)))

(defun scene-on-mouse-move (scene mouse-event)
  (let* ((widget-chain (get-widget-chain (list (hit-test (widget scene)
                                                         (mouse-x mouse-event)
                                                         (mouse-y mouse-event)))))
         (mouse-leave-widgets (calculate-mouse-leave (last-widget-chain scene)
                                                     widget-chain))
         (mouse-enter-widgets (calculate-mouse-enter (last-widget-chain scene)
                                                     widget-chain)))
    (setf (last-widget-chain scene) widget-chain)
    (cascade-then-bubble mouse-leave-widgets :mouse-leave mouse-event)
    (setf (handled mouse-event) nil)
    (cascade-then-bubble mouse-enter-widgets :mouse-enter mouse-event)
    (setf (handled mouse-event) nil)
    (cascade-then-bubble widget-chain :mouse-move mouse-event)
    (setf (handled mouse-event) nil)
    (scene-handle-mouse-captors scene :mouse-move mouse-event)))

(defun scene-on-mouse-button (scene event mouse-event)
  (let ((widget-chain (get-widget-chain (list (hit-test (widget scene)
                                                        (mouse-x mouse-event)
                                                        (mouse-y mouse-event))))))
    (cascade-then-bubble widget-chain event mouse-event)
    (scene-handle-mouse-captors scene event mouse-event)))

(defun set-focus (scene focus)
  (when (< (focused-index scene) (length (focusables scene)))
    (setf (has-focus (aref (focusables scene) (focused-index scene)))
          focus)))

(defun calculate-focusables (scene)
  (unless (focusables scene)
    (let (result)
      (paint-order-walk (widget scene)
                        (lambda (widget)
                          (when (focusable widget)
                            (push widget result))
                          t))
      (setf (focusables scene) (coerce (nreverse result) 'vector))
      (setf (focused-index scene) 0)
      (set-focus scene t))))

(defun focused-widget (scene)
  (calculate-focusables scene)
  (when (< (focused-index scene) (length (focusables scene)))
    (aref (focusables scene) (focused-index scene))))

(defun focus-next (scene)
  (calculate-focusables scene)
  (when (focused-widget scene)
    (invalidate (focused-widget scene)))
  (set-focus scene nil)
  (incf (focused-index scene))
  (when (= (focused-index scene) (length (focusables scene)))
    (setf (focused-index scene) 0))
  (when (focused-widget scene)
    (invalidate (focused-widget scene)))
  (set-focus scene t))

(defun focus-previous (scene)
  (calculate-focusables scene)
  (when (focused-widget scene)
    (invalidate (focused-widget scene)))
  (set-focus scene nil)
  (decf (focused-index scene))
  (when (< (focused-index scene) 0)
    (setf (focused-index scene) (max (1- (length (focusables scene)))
                                     0)))
  (when (focused-widget scene)
    (invalidate (focused-widget scene)))
  (set-focus scene t))

(defun shifted (modifiers)
  (if (consp modifiers)
      (cond ((or (eq (car modifiers) :mod-lshift)
                 (eq (car modifiers) :mod-rshift))
             t)
            (t (shifted (cdr modifiers))))))

(defun scene-on-key (scene event-kind key-event)
  (aif (focused-widget scene)
       (let ((widget-chain (get-widget-chain (list it))))
         (cascade-then-bubble widget-chain event-kind key-event)
         (when (not (handled key-event))
           (when (and (eq :key-down event-kind)
                      (eq (key key-event) :tab))
             (setf (handled key-event) t)
             (if (shifted (modifiers key-event))
                 (focus-previous scene)
                 (focus-next scene)))))))

(defmethod initialize-instance :after ((instance scene) &rest initargs)
  (declare (ignore initargs))
  (setf (parent (widget instance)) instance))

(defun measure-layout (scene)
  (unless (layedout scene)
    (measure scene (width scene) (height scene))
    (layout scene 0 0 (width scene) (height scene))
    (setf (layedout scene) t)))
